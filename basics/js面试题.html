<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端面试题 | MuYang Hu&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="实践是检验真理的唯一标准">
    <link rel="preload" href="/blog/assets/css/0.styles.1a67f354.css" as="style"><link rel="preload" href="/blog/assets/js/app.7ecebeac.js" as="script"><link rel="preload" href="/blog/assets/js/2.b88e876e.js" as="script"><link rel="preload" href="/blog/assets/js/4.20d7ee85.js" as="script"><link rel="prefetch" href="/blog/assets/js/3.7dbf0cc9.js"><link rel="prefetch" href="/blog/assets/js/5.8d0ad88c.js"><link rel="prefetch" href="/blog/assets/js/6.2b42b8f6.js"><link rel="prefetch" href="/blog/assets/js/7.469f8897.js"><link rel="prefetch" href="/blog/assets/js/8.83eda719.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1a67f354.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">MuYang Hu's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/basics/" class="nav-link router-link-active">
  前端实录
</a></div><div class="nav-item"><a href="https://github.com/MuYang-Hu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/basics/" class="nav-link router-link-active">
  前端实录
</a></div><div class="nav-item"><a href="https://github.com/MuYang-Hu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JS基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/basics/01.html" class="sidebar-link">JS 设计模式</a></li><li><a href="/blog/basics/js面试题.html" class="active sidebar-link">前端面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_1-flex-grow-flex-shrink-flex-basis-的概念" class="sidebar-link">1. flex-grow/flex-shrink/flex-basis 的概念</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_2-实现-instanceof" class="sidebar-link">2. 实现 instanceOf</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_3-匹配一段字符串中的-this-year-is-2000-中的" class="sidebar-link">3. 匹配一段字符串中的'this year is 2000$'中的$</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_4-宏任务和微任务执行顺序问题" class="sidebar-link">4.宏任务和微任务执行顺序问题</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_5-http-状态码，每个码代表的含义" class="sidebar-link">5.http 状态码，每个码代表的含义</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_6-new-number-3-是否等于-3？" class="sidebar-link">6. new Number(3) 是否等于 3？</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_7-页面输入-url-到页面加载显示完成，这个过程发生了什么？" class="sidebar-link">7. 页面输入 url 到页面加载显示完成，这个过程发生了什么？</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_8-回流和重绘" class="sidebar-link">8.回流和重绘</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_9-cookies-sessionstorage-和-localstorage-区别？" class="sidebar-link">9.cookies,sessionStorage 和 localStorage 区别？</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_10-怎么处理移动端-1px-被渲染成-2px-问题" class="sidebar-link">10.怎么处理移动端 1px 被渲染成 2px 问题</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_11-类型转换" class="sidebar-link">11.类型转换</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_12-promise-a-规范" class="sidebar-link">12.promise A+规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#术语" class="sidebar-link">术语</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#要求" class="sidebar-link">要求</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#then-方法" class="sidebar-link">Then 方法</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#promise-解决过程" class="sidebar-link">Promise 解决过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#_13-寄生组合继承和组合继承" class="sidebar-link">13.寄生组合继承和组合继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#组合继承" class="sidebar-link">组合继承</a></li><li class="sidebar-sub-header"><a href="/blog/basics/js面试题.html#寄生组合继承" class="sidebar-link">寄生组合继承</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端面试题"><a href="#前端面试题" class="header-anchor">#</a> 前端面试题</h1> <h2 id="_1-flex-grow-flex-shrink-flex-basis-的概念"><a href="#_1-flex-grow-flex-shrink-flex-basis-的概念" class="header-anchor">#</a> 1. flex-grow/flex-shrink/flex-basis 的概念</h2> <p><a href="http://static.vgee.cn/static/index.html" target="_blank" rel="noopener noreferrer">flex 学习链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>容器的属性：</p> <p><strong>针对父元素的属性：</strong></p> <p><strong>flex-direction 决定主轴的方向</strong>(row/row-reverse/column/column-reverse)</p> <p><strong>flex-wrap 决定一条轴线是否排不下时如何换行元素</strong>(now-wrap/wrap/wrap-reverse)</p> <p>flex-flow属性是<strong>flex-direction属性</strong>和<strong>flex-wrap属性</strong>的简写形式，默认值为row nowrap</p> <p><strong>justify-content 决定主轴的对齐方式</strong></p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around |
	space-evenly<span class="token punctuation">;</span>
</code></pre></div><p><strong>属性如下：</strong></p> <ol><li>flex-start 决定左对齐</li> <li>flex-end 决定右对齐</li> <li>center 居中对齐</li> <li>space-between 两端对齐，多余的空白间距在元素中间区域均分</li> <li>space-around 环绕 每个 flex 子项环绕相等的空白间距，两侧的空白只有中间间隔的一半</li> <li>space-evenly</li></ol> <p><strong>align-items 决定交叉轴的方式如何对齐</strong>(仅针对一根轴线)</p> <p>如果是多个轴线，<strong>使用 align-content 排列</strong></p> <p><strong>针对子元素的属性：</strong></p> <p><strong>flex-grow</strong> 定义项目的放大比例，<strong>默认为 0(如果存在剩余空间，也不放大)</strong></p> <p><strong>flex-shrink</strong> 定义了项目的缩小比例，<strong>默认为 1，即如果空间不足，该项目将缩小</strong></p> <p><strong>当空间不足时，都将等比例缩小，如果项目为 0，则不缩小</strong></p> <p>补充: flex-grow 是空间足够时候如何利用空间，flex-shrink 则是空间不足时候如何收缩腾出空间</p> <p><strong>flex-shrink 的计算规则：</strong></p> <p><img src="/blog/assets/img/js-01.dedc669b.png" alt="img"></p> <p><img src="/blog/assets/img/js-02.2d9cb8f2.png" alt="img"></p> <p><strong>flex-basis</strong> <strong>再分配多余的空间之前，项目的长度</strong>，合法值: auto/inherit 或%、px、em 或者其他长度单位，<strong>如果显式设置了 flex-shrink，会自动缩小到容器内而不溢出</strong></p> <p>当 flex:auto 时 相当于以上三个属性分别为 1 1 auto</p> <p>当 flex:none 时 相当于以上三个属性分别为 0 0 auto</p> <p><strong>初始化的属性：当 flex:initial 时 相当于以上三个属性分别为 0 1 auto</strong></p> <p>flex:1 相当于三个属性分别为 1 1 <number></number></p> <p>当 flex:inherit 时 从父元素继承该属性</p> <h2 id="_2-实现-instanceof"><a href="#_2-实现-instanceof" class="header-anchor">#</a> 2. 实现 instanceOf</h2> <blockquote><p>核心要点：原型链的向上查找</p></blockquote> <p>编写实现 instanceOf 代码：</p> <p>left 代表左变量，right 代表有变量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">==</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
		proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeof</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>instanceOf 常规代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>make <span class="token operator">=</span> make<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>year <span class="token operator">=</span> year<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> auto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">'Honda'</span><span class="token punctuation">,</span> <span class="token string">'Accord'</span><span class="token punctuation">,</span> <span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>auto <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// expected output: true</span>
<span class="token comment">// auto是left variable</span>
<span class="token comment">// Object是right variable</span>

</code></pre></div><h2 id="_3-匹配一段字符串中的-this-year-is-2000-中的"><a href="#_3-匹配一段字符串中的-this-year-is-2000-中的" class="header-anchor">#</a> 3. 匹配一段字符串中的'this year is 2000$'中的$</h2> <p>分析：</p> <p>由于$在正则表达式中式特殊含义的符号（代表尾部匹配，不能有空格），并且需要\来转义成普通的</p> <p>字符</p> <p>正则表达式如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'1112020$'</span>
<span class="token keyword">var</span> patt1 <span class="token operator">=</span> <span class="token regex">/2020\$$/</span>
document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>patt1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 返回2020$</span>
</code></pre></div><h2 id="_4-宏任务和微任务执行顺序问题"><a href="#_4-宏任务和微任务执行顺序问题" class="header-anchor">#</a> 4.宏任务和微任务执行顺序问题</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 打印结果是：2 4 1 3</span>
<span class="token comment">// 如果resolve直接执行，不放在宏任务里面就是 2 4 3 1</span>

</code></pre></div><h2 id="_5-http-状态码，每个码代表的含义"><a href="#_5-http-状态码，每个码代表的含义" class="header-anchor">#</a> 5.http 状态码，每个码代表的含义</h2> <table><thead><tr><th style="text-align:left;">分类</th> <th style="text-align:left;">分类描述</th></tr></thead> <tbody><tr><td style="text-align:left;">1**</td> <td style="text-align:left;">信息，服务器收到请求，<strong>需要请求者继续执行操作</strong></td></tr> <tr><td style="text-align:left;">2**</td> <td style="text-align:left;"><strong>成功</strong>，操作被成功接收并处理</td></tr> <tr><td style="text-align:left;">3**</td> <td style="text-align:left;"><strong>重定向</strong>，需要进一步的操作以完成请求</td></tr> <tr><td style="text-align:left;">4**</td> <td style="text-align:left;"><strong>客户端错误</strong>，请求包含语法错误或无法完成请求</td></tr> <tr><td style="text-align:left;">5**</td> <td style="text-align:left;"><strong>服务器错误</strong>，服务器在处理请求的过程中发生了错误</td></tr></tbody></table> <p><strong>常见的状态码列表</strong></p> <ul><li>200 - 请求成功</li> <li>301 - 资源（网页等）被永久转移到其它 URL</li> <li>404 - 请求的资源（网页等）不存在</li> <li>500 - 内部服务器错误</li></ul> <h2 id="_6-new-number-3-是否等于-3？"><a href="#_6-new-number-3-是否等于-3？" class="header-anchor">#</a> 6. new Number(3) 是否等于 3？</h2> <p>Number 对象是原始数值的<strong>包装对象</strong>。</p> <p>var num = new Number(value);</p> <p><strong>注意：</strong> <strong>如果一个参数值不能转换为一个数字将返回 NaN (非数字值)。</strong></p> <p>补充：</p> <p>三等号判断 会比较两个值是否相等，在比较前不进行隐式转换</p> <p>如果两个被比较的值具有不同的类型，即使有相同的值也是不全等的</p> <h2 id="_7-页面输入-url-到页面加载显示完成，这个过程发生了什么？"><a href="#_7-页面输入-url-到页面加载显示完成，这个过程发生了什么？" class="header-anchor">#</a> 7. 页面输入 url 到页面加载显示完成，这个过程发生了什么？</h2> <ul><li>DNS 解析</li> <li>TCP 连接</li> <li>发送 HTTP 请求</li> <li>服务器处理请求并返回 HTTP 报文</li> <li>浏览器解析渲染页面</li> <li>连接结束</li></ul> <p><strong>补充：http 请求的缓存流程</strong></p> <p><img src="/blog/assets/img/js-03.23ab06ab.png" alt="preview"></p> <h2 id="_8-回流和重绘"><a href="#_8-回流和重绘" class="header-anchor">#</a> 8.回流和重绘</h2> <p><a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener noreferrer">回流和重绘 详细阐述<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong>回流概念：</strong></p> <p>当render tree中的一部分(或全部)因为元素的<strong>规模尺寸，布局，隐藏</strong>等改变而需要重新构建。</p> <p><strong>重绘概念：</strong></p> <p>​	当render tree中的一些元素需要更新属性，而这些属性只是<strong>影响元素的外观，风格</strong>，<strong>而不会影响布</strong></p> <p><strong>局的</strong>，比如background-color。</p> <p>页面布局发生变化的时候，需要回流，比如以下情况：</p> <ol><li>添加或删除可见的 DOM 元素</li> <li>元素的位置发生变化 元素的尺寸发生变化(包括外边距、内边框，边框大小，高度和宽度等等）</li> <li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li> <li>页面一开始渲染时（正常回流，不用避免）</li> <li>浏览器窗口尺寸变化，是根据视口的大小来计算的</li></ol> <p>注意：<strong>回流一定触发重绘，而重绘不一定回流</strong></p> <h2 id="_9-cookies-sessionstorage-和-localstorage-区别？"><a href="#_9-cookies-sessionstorage-和-localstorage-区别？" class="header-anchor">#</a> <strong>9.cookies,sessionStorage 和 localStorage 区别？</strong></h2> <p>使用定义:</p> <ul><li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li> <li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li> <li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li></ul> <p>存储大小:</p> <ul><li><code>cookie</code>数据大小不能超过 4k</li> <li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到 5M 或更大</li></ul> <p>有效期:</p> <ul><li><code>localStorage</code> 存储持久数据，<strong>浏览器关闭后数据不丢失</strong>除非主动删除数据</li> <li><code>sessionStorage</code> 数据在<strong>当前浏览器窗口关闭后</strong>自动删除</li> <li><code>cookie</code> 设置的<code>cookie</code><strong>过期时间之前</strong>一直有效，即使窗口或浏览器关闭</li></ul> <h2 id="_10-怎么处理移动端-1px-被渲染成-2px-问题"><a href="#_10-怎么处理移动端-1px-被渲染成-2px-问题" class="header-anchor">#</a> 10.怎么处理移动端 1px 被渲染成 2px 问题</h2> <p><strong>局部处理</strong></p> <ul><li><code>meta</code>标签中的 <code>viewport</code>属性 ，<code>initial-scale</code> 设置为 <code>1</code></li> <li><code>rem</code>按照设计稿标准走，外加利用<code>transfrom 的</code>scale(0.5) 缩小一倍即可；</li></ul> <p><strong>全局处理</strong></p> <ul><li><code>meta标签中的</code>viewport<code>属性, initial-scale</code> 设置为 <code>0.5</code></li> <li><code>rem</code> 按照设计稿标准走即可</li></ul> <h2 id="_11-类型转换"><a href="#_11-类型转换" class="header-anchor">#</a> 11.类型转换</h2> <blockquote><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p></blockquote> <ul><li><p><strong>转换为布尔值</strong></p> <ul><li>除了<strong>0，-0，NAN 是 false</strong>之外都为 true</li> <li>string 中除了<strong>空字符串是 false</strong>之外都为 true</li> <li><strong>undefined、null 是 false</strong></li> <li>引用类型，比如数组、函数、对象都为<strong>true</strong></li></ul></li> <li><p><strong>转换为数字</strong></p></li> <li><p><strong>转换为字符串</strong></p> <ul><li><p>number =&gt; 'number'（number 为任意数字，包括 NaN,-Infinity,+Infinity）</p> <p>但是-0、+0 始终是'0'</p></li> <li><p>boolean/函数/symbol 结果就是加了双引号或单引号</p></li></ul></li></ul> <h2 id="_12-promise-a-规范"><a href="#_12-promise-a-规范" class="header-anchor">#</a> 12.promise A+规范</h2> <p><strong>译文术语</strong></p> <ul><li><strong>解决（fulfill）</strong>：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 <code>fulfill</code> 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li> <li><strong>拒绝（reject）</strong>：指一个 promise 失败时进行的一系列操作。</li> <li><strong>终值（eventual value）</strong>：所谓终值，指的是 promise 被<strong>解决</strong>时传递给解决回调的值，由于 promise 有<strong>一次性</strong>的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li> <li><strong>据因（reason）</strong>：也就是拒绝原因，指在 promise 被<strong>拒绝</strong>时传递给拒绝回调的值。</li></ul> <hr> <p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>then</code> 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。</p> <p>本规范详细列出了 <code>then</code> 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 <code>then</code> 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p> <p>从历史上说，本规范实际上是把之前 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener noreferrer">Promise/A 规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p> <p>最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。</p> <h3 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h3> <hr> <h4 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h4> <p>promise 是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范；</p> <h4 id="thenable"><a href="#thenable" class="header-anchor">#</a> thenable</h4> <p>是一个定义了 <code>then</code> 方法的对象或函数，文中译作“拥有 <code>then</code> 方法”；</p> <h4 id="值（value）"><a href="#值（value）" class="header-anchor">#</a> 值（value）</h4> <p>指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</p> <h4 id="异常（exception）"><a href="#异常（exception）" class="header-anchor">#</a> 异常（exception）</h4> <p>是使用 <code>throw</code> 语句抛出的一个值。</p> <h4 id="据因（reason）"><a href="#据因（reason）" class="header-anchor">#</a> 据因（reason）</h4> <p>表示一个 promise 的拒绝原因。</p> <h3 id="要求"><a href="#要求" class="header-anchor">#</a> 要求</h3> <hr> <h4 id="promise-的状态"><a href="#promise-的状态" class="header-anchor">#</a> Promise 的状态</h4> <p>一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、<strong>执行态（Fulfilled）</strong></p> <p>和<strong>拒绝态（Rejected）</strong>。</p> <p><strong>等待态（Pending）</strong></p> <p>处于等待态时，promise 需满足以下条件：</p> <ul><li>可以迁移至执行态或拒绝态</li></ul> <p><strong>执行态（Fulfilled）</strong></p> <p>处于执行态时，promise 需满足以下条件：</p> <ul><li>不能迁移至其他任何状态</li> <li>必须拥有一个<strong>不可变</strong>的终值</li></ul> <p><strong>拒绝态（Rejected）</strong></p> <p>处于拒绝态时，promise 需满足以下条件：</p> <ul><li>不能迁移至其他任何状态</li> <li>必须拥有一个<strong>不可变</strong>的据因</li></ul> <p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（**译者注：**盖指</p> <p>当 value 或 reason 不是基本值时，<strong>只要求其引用地址相等，但属性值可被更改</strong>）。</p> <h3 id="then-方法"><a href="#then-方法" class="header-anchor">#</a> <strong>Then 方法</strong></h3> <p>一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p> <p>promise 的 <code>then</code> 方法接受两个参数：</p> <div class="language- extra-class"><pre class="language-text"><code>promise.then(onFulfilled, onRejected)
</code></pre></div><h5 id="参数可选"><a href="#参数可选" class="header-anchor">#</a> 参数可选</h5> <p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p> <ul><li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略</li> <li>如果 <code>onRejected</code> 不是函数，其必须被忽略</li></ul> <h5 id="onfulfilled-特性"><a href="#onfulfilled-特性" class="header-anchor">#</a> <code>onFulfilled</code> 特性</h5> <p>如果 <code>onFulfilled</code> 是函数：</p> <ul><li>当 <code>promise</code> 执行结束后其必须被调用，其第一个参数为 <code>promise</code> 的终值</li> <li>在 <code>promise</code> 执行结束前其不可被调用</li> <li><strong>其调用次数不可超过一次</strong></li></ul> <h5 id="onrejected-特性"><a href="#onrejected-特性" class="header-anchor">#</a> <code>onRejected</code> 特性</h5> <p>如果 <code>onRejected</code> 是函数：</p> <ul><li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因</li> <li>在 <code>promise</code> 被拒绝执行前其不可被调用</li> <li>其调用次数不可超过一次</li></ul> <h5 id="调用时机"><a href="#调用时机" class="header-anchor">#</a> 调用时机</h5> <p><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener noreferrer">执行环境<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>堆栈仅包含<strong>平台代码</strong>时才可被调用[^注1]</p> <h5 id="调用要求"><a href="#调用要求" class="header-anchor">#</a> 调用要求</h5> <p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值）[^注2]</p> <h5 id="多次调用"><a href="#多次调用" class="header-anchor">#</a> 多次调用</h5> <p><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p> <ul><li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其<strong>注册顺序</strong>依次回调</li> <li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其<strong>注册顺序</strong>依次回调</li></ul> <h5 id="返回"><a href="#返回" class="header-anchor">#</a> 返回</h5> <p><strong><code>then</code> 方法必须返回一个 <code>promise</code> 对象</strong>[^注3]</p> <div class="language- extra-class"><pre class="language-text"><code>promise2 = promise1.then(onFulfilled, onRejected);
</code></pre></div><ul><li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></li> <li>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></li> <li>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</li> <li>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的据因</li></ul> <p>**译者注：**理解上面的“返回”部分非常重要，即：<strong>不论 <code>promise1</code> 被 reject 还是被 resolve 时 <code>promise2</code> 都会被 resolve，只有出现异常时才会被 rejected</strong>。</p> <h3 id="promise-解决过程"><a href="#promise-解决过程" class="header-anchor">#</a> <strong>Promise 解决过程</strong></h3> <p><strong>Promise 解决过程</strong>是一个抽象的操作，其需输入一个 <code>promise</code> 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 <code>promise</code> 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 <code>promise</code> 。</p> <p>这种 <em>thenable</em> 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 <code>then</code> 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p> <p>运行 <code>[[Resolve]](promise, x)</code> 需遵循以下步骤：</p> <h5 id="x-与-promise-相等"><a href="#x-与-promise-相等" class="header-anchor">#</a> <code>x</code> 与 <code>promise</code> 相等</h5> <p>如果 <code>promise</code> 和 <code>x</code> 指向同一对象，以 <code>TypeError</code> 为据因拒绝执行 <code>promise</code></p> <h5 id="x-为-promise"><a href="#x-为-promise" class="header-anchor">#</a> <code>x</code> 为 Promise</h5> <p>如果 <code>x</code> 为 Promise ，则使 <code>promise</code> 接受 <code>x</code> 的状态 [^注4]：</p> <ul><li>如果 <code>x</code> 处于等待态， <code>promise</code> 需保持为等待态直至 <code>x</code> 被执行或拒绝</li> <li>如果 <code>x</code> 处于执行态，用相同的值执行 <code>promise</code></li> <li>如果 <code>x</code> 处于拒绝态，用相同的据因拒绝 <code>promise</code></li></ul> <h5 id="x-为对象或函数"><a href="#x-为对象或函数" class="header-anchor">#</a> <code>x</code> 为对象或函数</h5> <p>如果 <code>x</code> 为对象或者函数：</p> <ul><li>把 <code>x.then</code> 赋值给 <code>then</code>[^注5]</li> <li>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为据因拒绝 <code>promise</code></li> <li>如果 then 是函数，将 x 作为函数的作用域，this 调用之。传递两个回调函数作为参数，第一个参数叫做<strong>resolvePromise</strong>，第二个参数叫做<strong>rejectPromise</strong>:
<ul><li>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li> <li>如果 <code>rejectPromise</code> 以据因 <code>r</code> 为参数被调用，则以据因 <code>r</code> 拒绝 <code>promise</code></li> <li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li> <li>如果调用 then 方法抛出了异常 e：
<ul><li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li> <li>否则以 <code>e</code> 为据因拒绝 <code>promise</code></li></ul></li> <li>如果 <code>then</code> 不是函数，以 <code>x</code> 为参数执行 <code>promise</code></li></ul></li> <li>如果 <code>x</code> 不为对象或者函数，以 <code>x</code> 为参数执行 <code>promise</code></li></ul> <p>如果一个 promise 被一个循环的 <em>thenable</em> 链中的对象解决，而 <code>[[Resolve]](promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 <code>TypeError</code> 为据因来拒绝 <code>promise</code> [^注6]。</p> <h5 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h5> <ul><li><p><strong>注 1</strong> 这里的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（**译者注：**即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</p> <p>译者注：这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</p> <p>两个类别的具体分类如下：</p> <ul><li><strong>macro-task:</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O, UI rendering</li> <li><strong>micro-task:</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code></li></ul> <p>详见 <a href="http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context" target="_blank" rel="noopener noreferrer">stackoverflow 解答<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a href="http://wengeezhang.com/?p=11" target="_blank" rel="noopener noreferrer">这篇博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><strong>注 2</strong> 也就是说在**严格模式（strict）**中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。</p></li></ul> <ul><li><p><strong>注 3</strong> 代码实现在满足所有要求的情况下可以允许 <code>promise2 === promise1</code> 。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code> 。</p></li> <li><p><strong>注 4</strong> 总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 <em>promise</em> 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。</p></li> <li><p><strong>注 5</strong> 这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code> 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p></li> <li><p><strong>注 6</strong> 实现不应该对 <em>thenable</em> 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 <code>TypeError</code> 异常；如果一条无限长的链上 <em>thenable</em> 均不相同，那么递归下去永远是正确的行为。</p></li></ul> <h2 id="_13-寄生组合继承和组合继承"><a href="#_13-寄生组合继承和组合继承" class="header-anchor">#</a> 13.寄生组合继承和组合继承</h2> <p><a href="https://zhuanlan.zhihu.com/p/63624812" target="_blank" rel="noopener noreferrer">继承-文章转载来源<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> <strong>组合继承</strong></h3> <p>缺点：两次调用 sup 函数</p> <ol><li>new sup</li> <li>sup.call</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Sup</span><span class="token punctuation">(</span><span class="token parameter">grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade
<span class="token punctuation">}</span>
<span class="token class-name">Sup</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayGrade</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Sup</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'一3班'</span><span class="token punctuation">)</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sup</span><span class="token punctuation">(</span><span class="token string">'一3班'</span><span class="token punctuation">)</span>
<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token string">'小强'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">sayGrade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>运行结果如下</p> <p><img src="https://pic1.zhimg.com/80/v2-b162d458b2fad514fc762d3d96e14c6c_720w.jpg" alt="img">组合继承</p> <p>可以看到实例上确实已经有了继承自<code>Sup</code>的<code>grade</code>属性和由<code>Sub</code>产生的<code>name</code>属性，在实例上执行<code>sayGrade</code>方法也能正确打印出结果。但可以看到由于<code>Sup</code>构造函数实例化了两次，在<code>Sub</code>的原型上也出现了<code>grade</code>属性。由于在实例上获取属性时会按原型链逐级往上找，而在实例上就已经获取到了<code>grade</code>属性，所以通常情况下原型上的这个属性不会生效，拥有这个“多余的”属性也无伤大雅。但在某些情况下会造成错误，例如删除实例上的<code>grade</code>属性，实际上还能访问到，此时获取到的是原型上的属性。</p> <p>问题就出在第一次的<code>new Sup('一3班')</code>上，只是为了<strong>继承原型上的实例和方法</strong>其实不必要执行该方法，寄生组合继承就可以解决这个问题。</p> <h3 id="寄生组合继承"><a href="#寄生组合继承" class="header-anchor">#</a> <strong>寄生组合继承</strong></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Sup</span><span class="token punctuation">(</span><span class="token parameter">grade</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>grade <span class="token operator">=</span> grade
<span class="token punctuation">}</span>
<span class="token class-name">Sup</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayGrade</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>grade<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Sup</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'一3班'</span><span class="token punctuation">)</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Sup</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token string">'小强'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>sayGrade<span class="token punctuation">)</span>
</code></pre></div><p>运行结果如下</p> <p><img src="https://pic2.zhimg.com/80/v2-5ed42693a29e020e7560b912577736be_720w.jpg" alt="img"></p> <p>可以看到，<code>Sub</code>的原型上已经没有<code>grade</code>属性，这是因为<code>Object.create(Sup.prototype)</code>方法返回一个以<code>Sup.prototype</code>为原型的对象，而不用执行<code>Sup</code>方法。</p> <p>显然寄生组合继承要比组合继承更加合理。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/basics/01.html" class="prev">
        JS 设计模式
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.7ecebeac.js" defer></script><script src="/blog/assets/js/2.b88e876e.js" defer></script><script src="/blog/assets/js/4.20d7ee85.js" defer></script>
  </body>
</html>
